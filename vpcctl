#!/usr/bin/env python3
"""
vpcctl - Virtual Private Cloud Management CLI
A tool to create and manage virtual VPCs on Linux using network namespaces
"""

import subprocess
import json
import sys
import os
from pathlib import Path
import hashlib

# Configuration
VPC_BASE_DIR = "/var/run/vpcctl"
LOG_FILE = "logs/vpcctl.log"

def log(message):
    """Log messages to console and file"""
    print(f"[vpcctl] {message}")
    Path("logs").mkdir(exist_ok=True)
    with open(LOG_FILE, "a") as f:
        f.write(f"{message}\n")

def run_cmd(cmd, capture=False):
    """Execute shell command with error handling"""
    log(f"Executing: {cmd}")
    try:
        if capture:
            result = subprocess.run(cmd, shell=True, check=True, 
                                  capture_output=True, text=True)
            return result.stdout.strip()
        else:
            subprocess.run(cmd, shell=True, check=True)
            return None
    except subprocess.CalledProcessError as e:
        log(f"ERROR: Command failed: {e}")
        return None

def short_name(name, max_len=12):
    """Create a short unique name within max_len characters"""
    if len(name) <= max_len:
        return name
    # Use first part + hash for uniqueness
    hash_suffix = hashlib.md5(name.encode()).hexdigest()[:4]
    prefix_len = max_len - 5  # Leave room for hash + hyphen
    return f"{name[:prefix_len]}-{hash_suffix}"

def create_vpc(vpc_name, cidr_block):
    """Create a new VPC with specified CIDR block"""
    log(f"Creating VPC: {vpc_name} with CIDR: {cidr_block}")
    
    # Create bridge for VPC (acts as router)
    bridge_name = f"br-{vpc_name}"
    run_cmd(f"sudo ip link add {bridge_name} type bridge")
    run_cmd(f"sudo ip link set {bridge_name} up")
    
    # Extract network IP for bridge (e.g., 10.0.0.1 from 10.0.0.0/16)
    network_ip = cidr_block.split('/')[0]
    base_parts = network_ip.split('.')
    bridge_ip = f"{base_parts[0]}.{base_parts[1]}.{base_parts[2]}.1/24"
    
    run_cmd(f"sudo ip addr add {bridge_ip} dev {bridge_name}")
    
    # Save VPC metadata
    vpc_data = {
        "name": vpc_name,
        "cidr": cidr_block,
        "bridge": bridge_name,
        "subnets": []
    }
    
    Path(VPC_BASE_DIR).mkdir(parents=True, exist_ok=True)
    with open(f"{VPC_BASE_DIR}/{vpc_name}.json", "w") as f:
        json.dump(vpc_data, f, indent=2)
    
    log(f"✓ VPC {vpc_name} created successfully")
    return True

def add_subnet(vpc_name, subnet_name, subnet_cidr, subnet_type="private"):
    """Add a subnet to existing VPC"""
    log(f"Adding {subnet_type} subnet {subnet_name} ({subnet_cidr}) to VPC {vpc_name}")
    
    # Load VPC data
    vpc_file = f"{VPC_BASE_DIR}/{vpc_name}.json"
    if not os.path.exists(vpc_file):
        log(f"ERROR: VPC {vpc_name} not found")
        return False
    
    with open(vpc_file, "r") as f:
        vpc_data = json.load(f)
    
    bridge_name = vpc_data["bridge"]
    ns_name = f"{vpc_name}-{subnet_name}"
    
    # Create SHORT interface names (max 15 chars for Linux)
    # Use 'vp' prefix + shortened names
    veth_host = short_name(f"vp-{subnet_name}", 12)
    veth_ns = short_name(f"vn-{subnet_name}", 12)
    
    log(f"Using interface names: {veth_host} <-> {veth_ns}")
    
    # Create network namespace (this is your "subnet")
    run_cmd(f"sudo ip netns add {ns_name}")
    
    # Create veth pair (virtual cable)
    run_cmd(f"sudo ip link add {veth_host} type veth peer name {veth_ns}")
    
    # Connect one end to bridge
    run_cmd(f"sudo ip link set {veth_host} master {bridge_name}")
    run_cmd(f"sudo ip link set {veth_host} up")
    
    # Move other end into namespace
    run_cmd(f"sudo ip link set {veth_ns} netns {ns_name}")
    
    # Configure IP inside namespace
    # The namespace interface needs an IP in the same /24 as the bridge
    # Extract the VPC CIDR to get bridge subnet
    vpc_cidr = vpc_data['cidr']
    vpc_parts = vpc_cidr.split('/')[0].split('.')
    
    # Namespace gets IP in x.x.0.0/24 subnet (same as bridge)
    # Bridge has x.x.0.1, namespace gets x.x.0.10 + offset
    subnet_ip = subnet_cidr.split('/')[0]
    subnet_parts = subnet_ip.split('.')
    # Use the third octet from subnet CIDR as offset (e.g., 10.0.1.0 -> offset 1)
    offset = int(subnet_parts[2])
    
    # Assign IP in bridge subnet with offset
    host_ip = f"{vpc_parts[0]}.{vpc_parts[1]}.0.{10 + offset}/24"
    gateway = f"{vpc_parts[0]}.{vpc_parts[1]}.{vpc_parts[2]}.1"
    
    log(f"Assigning IP {host_ip} with gateway {gateway}")
    
    run_cmd(f"sudo ip netns exec {ns_name} ip addr add {host_ip} dev {veth_ns}")
    run_cmd(f"sudo ip netns exec {ns_name} ip link set {veth_ns} up")
    run_cmd(f"sudo ip netns exec {ns_name} ip link set lo up")
    
    # Add default route
    run_cmd(f"sudo ip netns exec {ns_name} ip route add default via {gateway} dev {veth_ns}")
    
    # Update VPC metadata
    vpc_data["subnets"].append({
        "name": subnet_name,
        "cidr": subnet_cidr,
        "type": subnet_type,
        "namespace": ns_name,
        "veth_host": veth_host,
        "veth_ns": veth_ns
    })
    
    with open(vpc_file, "w") as f:
        json.dump(vpc_data, f, indent=2)
    
    log(f"✓ Subnet {subnet_name} added successfully")
    return True

def setup_nat(vpc_name, internet_interface="eth0"):
    """Enable NAT for public subnets"""
    log(f"Setting up NAT gateway for VPC {vpc_name}")
    
    vpc_file = f"{VPC_BASE_DIR}/{vpc_name}.json"
    with open(vpc_file, "r") as f:
        vpc_data = json.load(f)
    
    cidr = vpc_data["cidr"]
    
    # Enable IP forwarding
    run_cmd("sudo sysctl -w net.ipv4.ip_forward=1")
    
    # Setup NAT using iptables
    run_cmd(f"sudo iptables -t nat -A POSTROUTING -s {cidr} -o {internet_interface} -j MASQUERADE")
    run_cmd(f"sudo iptables -A FORWARD -i {vpc_data['bridge']} -o {internet_interface} -j ACCEPT")
    run_cmd(f"sudo iptables -A FORWARD -i {internet_interface} -o {vpc_data['bridge']} -m state --state RELATED,ESTABLISHED -j ACCEPT")
    
    log("✓ NAT gateway configured")
    return True

def list_vpcs():
    """List all VPCs"""
    if not os.path.exists(VPC_BASE_DIR):
        log("No VPCs found")
        return
    
    vpc_files = list(Path(VPC_BASE_DIR).glob("*.json"))
    if not vpc_files:
        log("No VPCs found")
        return
    
    log("\n=== VPC List ===")
    for vpc_file in vpc_files:
        with open(vpc_file, "r") as f:
            vpc_data = json.load(f)
        log(f"\nVPC: {vpc_data['name']}")
        log(f"  CIDR: {vpc_data['cidr']}")
        log(f"  Bridge: {vpc_data['bridge']}")
        log(f"  Subnets: {len(vpc_data['subnets'])}")
        for subnet in vpc_data['subnets']:
            log(f"    - {subnet['name']} ({subnet['cidr']}) [{subnet['type']}]")

def delete_vpc(vpc_name):
    """Delete VPC and all resources"""
    log(f"Deleting VPC: {vpc_name}")
    
    vpc_file = f"{VPC_BASE_DIR}/{vpc_name}.json"
    if not os.path.exists(vpc_file):
        log(f"ERROR: VPC {vpc_name} not found")
        return False
    
    with open(vpc_file, "r") as f:
        vpc_data = json.load(f)
    
    # Delete all namespaces
    for subnet in vpc_data['subnets']:
        ns_name = subnet['namespace']
        run_cmd(f"sudo ip netns del {ns_name}")
        log(f"  Deleted namespace: {ns_name}")
    
    # Delete bridge
    bridge_name = vpc_data['bridge']
    run_cmd(f"sudo ip link set {bridge_name} down")
    run_cmd(f"sudo ip link del {bridge_name}")
    log(f"  Deleted bridge: {bridge_name}")
    
    # Remove VPC file
    os.remove(vpc_file)
    log(f"✓ VPC {vpc_name} deleted successfully")
    return True

def show_help():
    """Display help message"""
    help_text = """
vpcctl - Virtual Private Cloud Management CLI

USAGE:
    ./vpcctl <command> [options]

COMMANDS:
    create-vpc <name> <cidr>           Create a new VPC
    add-subnet <vpc> <name> <cidr> <type>  Add subnet (type: public/private)
    setup-nat <vpc> [interface]        Enable NAT gateway
    list                                List all VPCs
    delete-vpc <name>                  Delete VPC and all resources
    help                                Show this help

EXAMPLES:
    ./vpcctl create-vpc myvpc 10.0.0.0/16
    ./vpcctl add-subnet myvpc public-subnet 10.0.1.0/24 public
    ./vpcctl add-subnet myvpc private-subnet 10.0.2.0/24 private
    ./vpcctl setup-nat myvpc eth0
    ./vpcctl list
    ./vpcctl delete-vpc myvpc
"""
    print(help_text)

def main():
    if len(sys.argv) < 2:
        show_help()
        sys.exit(1)
    
    command = sys.argv[1]
    
    if command == "create-vpc":
        if len(sys.argv) != 4:
            log("Usage: ./vpcctl create-vpc <name> <cidr>")
            sys.exit(1)
        create_vpc(sys.argv[2], sys.argv[3])
    
    elif command == "add-subnet":
        if len(sys.argv) != 6:
            log("Usage: ./vpcctl add-subnet <vpc> <name> <cidr> <type>")
            sys.exit(1)
        add_subnet(sys.argv[2], sys.argv[3], sys.argv[4], sys.argv[5])
    
    elif command == "setup-nat":
        interface = sys.argv[3] if len(sys.argv) > 3 else "eth0"
        setup_nat(sys.argv[2], interface)
    
    elif command == "list":
        list_vpcs()
    
    elif command == "delete-vpc":
        if len(sys.argv) != 3:
            log("Usage: ./vpcctl delete-vpc <name>")
            sys.exit(1)
        delete_vpc(sys.argv[2])
    
    elif command == "help":
        show_help()
    
    else:
        log(f"Unknown command: {command}")
        show_help()
        sys.exit(1)

if __name__ == "__main__":
    main()
